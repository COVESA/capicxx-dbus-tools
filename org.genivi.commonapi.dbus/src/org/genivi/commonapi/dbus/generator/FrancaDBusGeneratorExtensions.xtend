/* Copyright (C) 2013-2020 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/. */
package org.genivi.commonapi.dbus.generator

import java.util.Collection
import java.util.HashSet
import java.util.Set
import javax.inject.Inject
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.franca.core.franca.FArgument
import org.franca.core.franca.FArrayType
import org.franca.core.franca.FAttribute
import org.franca.core.franca.FBasicTypeId
import org.franca.core.franca.FBroadcast
import org.franca.core.franca.FEnumerationType
import org.franca.core.franca.FInterface
import org.franca.core.franca.FMapType
import org.franca.core.franca.FMethod
import org.franca.core.franca.FModelElement
import org.franca.core.franca.FStructType
import org.franca.core.franca.FType
import org.franca.core.franca.FTypeCollection
import org.franca.core.franca.FTypeDef
import org.franca.core.franca.FTypeRef
import org.franca.core.franca.FTypedElement
import org.franca.core.franca.FUnionType
import org.genivi.commonapi.core.generator.FrancaGeneratorExtensions
import org.genivi.commonapi.dbus.deployment.PropertyAccessor
import org.genivi.commonapi.dbus.preferences.FPreferencesDBus
import org.genivi.commonapi.dbus.preferences.PreferenceConstantsDBus
import org.osgi.framework.FrameworkUtil

import static com.google.common.base.Preconditions.*
import org.franca.core.franca.FIntegerInterval

class FrancaDBusGeneratorExtensions {
	@Inject extension FrancaGeneratorExtensions
    @Inject extension FrancaDBusDeploymentAccessorHelper

    def generateCommonApiDBusLicenseHeader() '''
        /*
        * This file was generated by the CommonAPI Generators.
        * Used org.genivi.commonapi.dbus «getDBusVersion()».
        * Used org.franca.core «FrancaGeneratorExtensions::getFrancaVersion()».
        *
        «getCommentedString(getDBusLicenseHeader())»
        */
    '''

    def getDBusLicenseHeader() {
        return FPreferencesDBus::instance.getPreference(PreferenceConstantsDBus::P_LICENSE_DBUS, PreferenceConstantsDBus.DEFAULT_LICENSE)
    }

    def PropertyAccessor getDBusAccessor(FTypeCollection _tc) {
        var dbusAccessor = getAccessor(_tc)
        if (dbusAccessor instanceof PropertyAccessor)
            return dbusAccessor
        else
            return null
    }

    def String dbusDeploymentHeaderFile(FInterface _interface) {        
        return _interface.elementName + "DBusDeployment.hpp"
    }

    def String dbusDeploymentHeaderPath(FInterface _interface) {
        return _interface.versionPathPrefix + _interface.model.directoryPath + '/' + 
        	_interface.dbusDeploymentHeaderFile
    }

    def String dbusDeploymentSourceFile(FInterface _interface) {
        return _interface.elementName + "DBusDeployment.cpp"
    }

    def String dbusDeploymentSourcePath(FInterface _interface) {
        return _interface.versionPathPrefix + _interface.model.directoryPath + '/' + 
        	_interface.dbusDeploymentSourceFile
    }

    def dbusInSignature(FMethod _method, PropertyAccessor _accessor) {
        _method.inArgs.map[getTypeDbusSignature(_accessor.getOverwriteAccessor(it))].join;
    }

    def dbusOutSignature(FMethod _method, PropertyAccessor _accessor) {
        var signature = _method.outArgs.map[getTypeDbusSignature(_accessor.getOverwriteAccessor(it))].join;

        if (_method.hasError)
            signature = _method.dbusErrorSignature(_accessor) + signature

        return signature
    }

    def dbusErrorSignature(FMethod _method, PropertyAccessor _accessor) {
        checkArgument(_method.hasError, 'FMethod has no error: ' + _method)
       
        if (_accessor === null)
            return ""

        if (_method.errorEnum !== null)
            return _method.errorEnum.dbusFTypeSignature(_accessor)

        return _method.errors.dbusFTypeSignature(_accessor)
    }

    def dbusErrorReplyOutSignature(FBroadcast _broadcast, FMethod _method, PropertyAccessor _accessor) {
        checkArgument(_broadcast.isErrorType(_accessor), 'FBroadcast is no valid error type: ' + _broadcast)

        var signature = "s";
        if(!_broadcast.errorArgs(_accessor).empty) {
            signature = _broadcast.errorArgs(_accessor).map[getTypeDbusSignature(_accessor)].join;
        }
        return signature
    }

    def dbusSetMethodName(FAttribute _attribute) {
        'set' + _attribute.className
    }

    def dbusGetMethodName(FAttribute _attribute) {
        'get' + _attribute.className
    }

    def dbusSignalName(FAttribute _attribute) {
        'on' + _attribute.className + 'Changed'
    }

    def String dbusSignature(FAttribute _attribute, PropertyAccessor _accessor) {
        _attribute.getTypeDbusSignature(_accessor.getOverwriteAccessor(_attribute))
    }

    def String dbusSignature(FBroadcast _broadcast, PropertyAccessor _accessor) {
        _broadcast.outArgs.map[getTypeDbusSignature(_accessor.getOverwriteAccessor(it))].join
    }

    def getTypeDbusSignature(FTypedElement _element, PropertyAccessor _accessor) {
        if (_element.array) {
            return "a" + _element.typeDbusSignature(_accessor)
        } else {
            return _element.typeDbusSignature(_accessor)
        }
    }

    def String typeDbusSignature(FTypedElement _element, PropertyAccessor _accessor) {
        var FTypeRef fTypeRef = _element.type
        if (fTypeRef === null)
            return "";
        // test for getIsObjectPath
        var Boolean test = _accessor.getDBusIsObjectPathHelper(_element);
        if (test !== null && test)
            return "o"
        // test for getIsUnixFD
        var Boolean testFD = _accessor.getDBusIsUnixFDHelper(_element);
        if (testFD !== null && testFD)
            return "h"

        var PropertyAccessor.DBusVariantType variantType = _accessor.getDBusVariantTypeHelper(_element);
        if (variantType !== null && variantType == PropertyAccessor.DBusVariantType.DBus) {
            return "v"
        }

        if (fTypeRef.derived !== null)
            return fTypeRef.derived.dbusFTypeSignature(_accessor)
        if (fTypeRef.interval !== null)
            return FBasicTypeId::INT32.dbusSignature
        return fTypeRef.predefined.dbusSignature
    }

    def String dbusSignature(FTypeRef _typeRef, PropertyAccessor _accessor) {
        if (_typeRef === null)
            return "";

        if (_typeRef.derived !== null)
            return _typeRef.derived.dbusFTypeSignature(_accessor)
        if (_typeRef.interval !== null)
            return dbusSignature(FBasicTypeId::INT32)
        return _typeRef.predefined.dbusSignature
    }

    def private dispatch dbusFTypeSignature(FTypeDef _typeDef, PropertyAccessor _accessor) {
        return _typeDef.actualType.dbusSignature(_accessor)
    }

    def private dispatch dbusFTypeSignature(FArrayType _arrayType, PropertyAccessor _accessor) {
        return 'a' + _arrayType.elementType.dbusSignature(_accessor.getOverwriteAccessor(_arrayType))
    }

    def private dispatch dbusFTypeSignature(FMapType _map, PropertyAccessor _accessor) {
        return 'a{' + _map.keyType.dbusSignature(_accessor) + _map.valueType.dbusSignature(_accessor) + '}'
    }

    def private dispatch dbusFTypeSignature(FStructType _struct, PropertyAccessor _accessor) {
        if (_struct.isPolymorphic)
            return '(uv)'
        return '(' + _struct.getElementsDBusSignature(_accessor) + ')'
    }

    def private dispatch dbusFTypeSignature(FEnumerationType _enum, PropertyAccessor _accessor) {
        val FBasicTypeId backingType = _enum.getBackingType(_accessor)

        if (backingType == FBasicTypeId.UNDEFINED)
            return FBasicTypeId.INT32.dbusSignature

        return backingType.dbusSignature
    }

    def private dispatch dbusFTypeSignature(FUnionType _union, PropertyAccessor deploymentAccessor) {
        var PropertyAccessor.DBusVariantType variantType = deploymentAccessor.getDBusVariantTypeHelper(_union);
        if (variantType !== null && variantType == PropertyAccessor.DBusVariantType.DBus) {
            return "v"
        }
        return '(yv)'
    }

    def private String getElementsDBusSignature(FStructType _struct, PropertyAccessor _accessor) {
        var signature = _struct.elements.map[getTypeDbusSignature(_accessor.getOverwriteAccessor(it))].join

        if (_struct.base !== null) {
            signature = _struct.base.getElementsDBusSignature(_accessor) + signature
        }

        return signature
    }

    def private dbusSignature(FBasicTypeId _basicTypeId) {
        switch _basicTypeId {
            case FBasicTypeId::BOOLEAN: 'b'
            case FBasicTypeId::INT8: 'y'
            case FBasicTypeId::UINT8: 'y'
            case FBasicTypeId::INT16: 'n'
            case FBasicTypeId::UINT16: 'q'
            case FBasicTypeId::INT32: 'i'
            case FBasicTypeId::UINT32: 'u'
            case FBasicTypeId::INT64: 'x'
            case FBasicTypeId::UINT64: 't'
            case FBasicTypeId::FLOAT: 'd'
            case FBasicTypeId::DOUBLE: 'd'
            case FBasicTypeId::STRING: 's'
            case FBasicTypeId::BYTE_BUFFER: 'ay'
            default: throw new IllegalArgumentException("Unsupported basic type: " + _basicTypeId.getName)
        }
    }

    def getDBusVersion() {
        val bundle = FrameworkUtil::getBundle(this.getClass())
        val bundleContext = bundle.getBundleContext();
        for (b : bundleContext.bundles) {
            if (b.symbolicName.equals("org.genivi.commonapi.dbus")) {
                return b.version
            }
        }
    }

    def boolean isVariant(FAttribute _attribute) {
        return _attribute.type.isVariantType()
    }

    def private dispatch boolean isVariantType(FTypeRef _typeRef) {
        if (_typeRef.derived !== null)
            return _typeRef.derived.isVariantType()

        return false
    }

    def private dispatch boolean isVariantType(FTypeDef _typeDef) {
        return isVariantType(_typeDef.actualType)
    }

    def private dispatch boolean isVariantType(FType _type) {
        return (_type instanceof FUnionType)
    }

    def addRequiredHeaders(FType fType, Collection<String> generatedHeaders) {
        generatedHeaders.add(fType.FTypeCollection.dbusDeploymentHeaderPath)
    }

    def FTypeCollection findTypeCollection(EObject fType) {
        if (fType.eContainer === null)
            return null
        if (fType.eContainer instanceof FTypeCollection)
            return fType.eContainer as FTypeCollection
        return findTypeCollection(fType.eContainer)
    }

    def getFTypeCollection(FType fType) {
        fType.eContainer as FTypeCollection
    }
    def String dbusDeploymentHeaderPath(FTypeCollection _tc) {
        return _tc.versionPathPrefix + _tc.model.directoryPath + '/' + _tc.dbusDeploymentHeaderFile
    }
    def String dbusDeploymentHeaderFile(FTypeCollection _tc) {
        return _tc.elementName + "DBusDeployment.hpp"
    }
    def String dbusDeploymentSourcePath(FTypeCollection _tc) {
        return _tc.versionPathPrefix + _tc.model.directoryPath + '/' + _tc.dbusDeploymentSourceFile
    }
     def String dbusDeploymentSourceFile(FTypeCollection _tc) {
        return _tc.elementName + "DBusDeployment.cpp"
    }
    ////////////////////////////////////////
    // Get deployment type for an element //
    ////////////////////////////////////////
    def dispatch String getDeploymentType(FTypeDef _typeDef, FTypeCollection _interface, boolean _useTc) {
        return _typeDef.actualType.getDeploymentType(_interface, _useTc)
    }

    def dispatch String getDeploymentType(FTypedElement _typedElement, FTypeCollection _interface, boolean _useTc) {
        if (_typedElement.array)
            return "CommonAPI::DBus::ArrayDeployment< "
            	+ _typedElement.type.getDeploymentType(_interface, _useTc) + " >"
        return _typedElement.type.getDeploymentType(_interface, _useTc)
    }

    def dispatch String getDeploymentType(FTypeRef _typeRef, FTypeCollection _interface, boolean _useTc) {
        if (_typeRef.derived !== null)
            return _typeRef.derived.getDeploymentType(_interface, _useTc)
        if (_typeRef.interval !== null)
            return _typeRef.interval.getDeploymentType(_interface, _useTc)
        if (_typeRef.predefined !== null)
            return _typeRef.predefined.getDeploymentType(_interface, _useTc)

        return "CommonAPI::EmptyDeployment"
    }
    
    def dispatch String getDeploymentType(FIntegerInterval _interval, FTypeCollection _interface, boolean _useTc) {
       return "CommonAPI::EmptyDeployment"
    }
    
    def dispatch String getDeploymentType(FBasicTypeId _type, FTypeCollection _interface, boolean _useTc) {

        if (_type == FBasicTypeId.STRING)
            return "CommonAPI::DBus::StringDeployment"
        if (_type == FBasicTypeId.UINT32)
            return "CommonAPI::DBus::IntegerDeployment"
        if (_type == FBasicTypeId.INT32)
            return "CommonAPI::DBus::IntegerDeployment"
       return "CommonAPI::EmptyDeployment"
    }

    def dispatch String getDeploymentType(FEnumerationType _enum, FTypeCollection _interface, boolean _useTc) {
        return "CommonAPI::EmptyDeployment"
    }

    def dispatch String getDeploymentType(FType _type, FTypeCollection _interface, boolean _useTc) {
        var String deploymentType = ""

        if (_useTc) {
        	deploymentType = _type.eContainer.getFullName() + "_::"
        }
        deploymentType += _type.name + "Deployment_t"
    }

    ////////////////////////////////////////
    // Get deployment type for an element //
    ////////////////////////////////////////
    def String getDeploymentName(FTypedElement _typedElement, FModelElement _element, FTypeCollection _tc,
    	PropertyAccessor _accessor) {
        if (_accessor !== null && _accessor.hasSpecificDeployment(_typedElement) ||
            _typedElement.array && _accessor.hasDeployment(_typedElement)) {

            var String accessorName = _accessor.name
            // remove rightmost '_' for compatibility's sake
            if (_accessor.name.length > 0)
                accessorName = _accessor.name.substring(0, _accessor.name.length() - 1)

            var String deployment = _tc.fullName + "_::"
            deployment += accessorName + "Deployment"
            return deployment
        } else {
            return _typedElement.type.getDeploymentName(_tc, _accessor)
        }
    }

    def dispatch String getDeploymentName(FTypeDef _typeDef, FTypeCollection _tc, PropertyAccessor _accessor) {
        return _typeDef.actualType.getDeploymentName(_tc, _accessor)
    }

    def dispatch String getDeploymentName(FTypeRef _typeRef, FTypeCollection _tc, PropertyAccessor _accessor) {
        if (_typeRef.derived !== null) {
            return _typeRef.derived.getDeploymentName(_tc, _accessor)
        }
        else if (_typeRef.interval !== null) {
            return _typeRef.interval.getDeploymentName(_tc, _accessor)
        }
        return _typeRef.predefined.getDeploymentName(_tc, _accessor)
    }

    def dispatch String getDeploymentName(FType _type, FTypeCollection _tc, PropertyAccessor _accessor) {
        if (_accessor !== null && _accessor.hasDeployment(_type) ) {
            if (_accessor.isProperOverwrite()) {
                return _tc.getFullName + "_::" + _accessor.getName() +  _type.name + "Deployment"
            } else {
	            val container = _type.eContainer() as  FTypeCollection
                return container.getFullName + "_::" + _type.name + "Deployment"
            }
        }
        return ""
    }
    def dispatch String getDeploymentName(FIntegerInterval _interval, FTypeCollection _tc, PropertyAccessor _accessor) {
        return ""
    }
    def dispatch String getDeploymentName(FBasicTypeId _typeId, FTypeCollection _tc, PropertyAccessor _accessor) {
        return ""
    }
    
    ///////////////////////////////////////////////////////////
    // Get reference (C++ pointer) to a deployment parameter //
    ///////////////////////////////////////////////////////////
    def String getDeploymentRef(FTypedElement _typedElement, boolean _isArray, FModelElement _element,
        FInterface _interface, PropertyAccessor _accessor) {
        val String name = _typedElement.getDeploymentName(_element, _interface, _accessor)
        if (name != "")
            return "&" + name

        var String deployment = "static_cast< "
        deployment += _typedElement.getDeploymentType(_interface, true)
        deployment += "* >(nullptr)"
        return deployment
    }

    def String getErrorDeploymentRef(FMethod _method, FInterface _interface, PropertyAccessor _accessor) {
        var String name = ""
        if (_method.errorEnum !== null) {
            name += _method.errorEnum.getDeploymentName(_interface, _accessor)
            if (name != "")
                return "&" + name
        }
        return "static_cast< " + _method.getErrorDeploymentType(false) + " * >(nullptr)"
    }

    

    ////////////////////
    // Get deployable //
    ////////////////////
    def String getDeployable(FArgument _argument, FInterface _interface, PropertyAccessor _accessor) {
        return "CommonAPI::Deployable< " + _argument.getTypeName(_interface, true) + ", " + _argument.getDeploymentType(_interface, true) + " >"
    }

    def String getDeployables(EList<FArgument> _arguments, FInterface _interface, PropertyAccessor _accessor) {
        return _arguments.map[getDeployable(_interface, _accessor.getOverwriteAccessor(it))].join(", ")
    }

    def String getDeploymentTypes(EList<FArgument> _arguments, FInterface _interface, PropertyAccessor _accessor) {
        return _arguments.map[getDeploymentType(_interface, true)].join(", ")
    }

    def boolean hasDeployedArgument(FBroadcast _broadcast, PropertyAccessor _accessor) {
        for (a : _broadcast.outArgs) {
            if (_accessor.getOverwriteAccessor(a).hasDeployment(a)) {
                return true
            }
        }
        return false
    }

    def String getDeployments(FBroadcast _broadcast,
                              FInterface _interface,
                              PropertyAccessor _accessor) {
        return "std::make_tuple(" + _broadcast.outArgs.map[
        			getDeploymentRef(it.array, _broadcast, _interface, 
        				if (_accessor === null) _accessor else _accessor.getOverwriteAccessor(it)
        			)].join(", ")  + ")"
   }

    def boolean hasDeployedArgument(FMethod _method, PropertyAccessor _accessor,
                                    boolean _in, boolean _out) {
        if (_in) {
            for (a : _method.inArgs) {
                if (_accessor.getOverwriteAccessor(a).hasDeployment(a)) {
                    return true
                }
            }
        }

        if (_out) {
            for (a : _method.outArgs) {
                if (_accessor.getOverwriteAccessor(a).hasDeployment(a)) {
                    return true
                }
            }
        }

        return false
    }

    def String getDeployments(FMethod _method,
                              FInterface _interface,
                              PropertyAccessor _accessor,
                              boolean _withInArgs, boolean _withOutArgs) {
        var String inArgsDeployments = ""
        if (_withInArgs) {
            inArgsDeployments = _method.inArgs.map[getDeploymentRef(it.array, _method, _interface,  if (_accessor === null) _accessor else _accessor.getOverwriteAccessor(it))].join(", ")
        }

        var String outArgsDeployments = ""
        if (_withOutArgs) {
            outArgsDeployments = _method.outArgs.map[getDeploymentRef(it.array, _method, _interface, if (_accessor === null) _accessor else _accessor.getOverwriteAccessor(it))].join(", ")
            if (_method.hasError) {
                var String errorDeployment = _method.getErrorDeploymentRef(_interface, _accessor)
                if (outArgsDeployments != "")
                    outArgsDeployments = errorDeployment + ", " + outArgsDeployments
                else
                    outArgsDeployments = errorDeployment
            }
        }

        var String deployments = inArgsDeployments
        if (outArgsDeployments != "") {
            if (deployments != "") deployments += ", "
            deployments += outArgsDeployments
        }

        return "std::make_tuple(" + deployments + ")"
    }

    def String getProxyOutArguments(FMethod _method, FInterface _interface, PropertyAccessor _accessor) {
        val boolean isDeployed = _method.hasDeployedArgument(_accessor, false, true)
        var String error = ""
        if (_method.hasError) {
            if (isDeployed) {
                error = "_error, "
            } else {
                error = _method.getErrorNameReference(_method.eContainer) + ", "
            }
        }

        if (isDeployed) {
            return "std::make_tuple(" + error + _method.outArgs.map["deploy_" + elementName].join(", ") + ")"
        } else {
            return "std::tuple<" + error + _method.outTypeList + ">()"
        }
    }

    def String generateDeployedStubSignature(FMethod _method, FInterface _interface, PropertyAccessor _accessor) {
        var String arguments = "const std::shared_ptr<CommonAPI::ClientId> _client"
        for (a : _method.inArgs) {
            arguments += ", const " + a.getDeployable(_interface, _accessor.getOverwriteAccessor(a)) + " &_" + a.name
        }
        arguments += ", " + _method.elementName + "DBusReply_t _reply"
        return arguments
    }

    def generateDBusStubReturnSignature(FMethod _method, FInterface _interface, PropertyAccessor _accessor) {
        var signature = ""

        if (_method.hasError)
            signature += _method.getErrorNameReference(_method.eContainer) + ' _error'
        if (_method.hasError && !_method.outArgs.empty)
            signature += ', '

        if (!_method.outArgs.empty)
            signature += _method.outArgs.map[getDeployable(_interface, _accessor.getOverwriteAccessor(it)) + ' _' + elementName].join(', ')

        return signature
    }

    def generateArgumentsToDBusStub(FMethod _method, PropertyAccessor _accessor) {
        var arguments = ' _client'

        for (a : _method.inArgs) {
            if (_accessor.getOverwriteAccessor(a).hasDeployment(a)) {
                arguments += ", _" + a.name + ".getValue()"
            } else {
                arguments += ", _" + a.name
            }
        }

        if (!_method.isFireAndForget)
            arguments = arguments + ', _reply'

        return arguments
    }

    ///////////////////////////////////////////////////////////
    // Get reference (C++ pointer) to a deployment parameter //
    ///////////////////////////////////////////////////////////
    def String getDeploymentRef(FTypedElement _typedElement, FModelElement _element, FTypeCollection _tc, PropertyAccessor _accessor) {
        if (_accessor !== null) {
	        val String name = _typedElement.getDeploymentName(_element, _tc, _accessor)
	        if (name != "")
	            return "&" + name
		}
		
		var String elemType = ''
		
		if (_typedElement.type.derived !== null) {
			val containerName = _typedElement.type.derived.eContainer.fullName
			val typeName = _typedElement.type.derived.name
			elemType = containerName + "_::" + typeName + "Deployment_t"
			if (_typedElement.array)
				elemType = "CommonAPI::DBus::ArrayDeployment<" + elemType + ">"
		} else {
			elemType = _typedElement.getDeploymentType(null, false)
		}
		
		return "static_cast< " + elemType + "* >(nullptr)"
    }

    def String getDeploymentRef(FTypeRef _typeRef, FTypeCollection _tc, PropertyAccessor _accessor) {
        val String name = _typeRef.getDeploymentName(_tc, _accessor)
        if (name != "")
            return "&" + name

        if(_typeRef.derived !== null) {
            if(_typeRef.derived instanceof FEnumerationType) {
                return "static_cast< " + _typeRef.derived.getDeploymentType(null, true) + "* >(nullptr)"
            }
            var containerName =_typeRef.derived.eContainer.fullName
            var typeName =_typeRef.derived.name
            return "static_cast< " + containerName + "_::" + typeName + "Deployment_t* >(nullptr)"
        }

        return "static_cast< " + _typeRef.getDeploymentType(null, false) + "* >(nullptr)"
    }

    def String getDeploymentRef(FType _type, FTypeCollection _tc, PropertyAccessor _accessor) {
        val String name = _type.getDeploymentName(_tc, _accessor)
        if (name != "")
            return "&" + name

        return "static_cast< " + _type.getDeploymentType(_tc, true) + "* >(nullptr)"
    }

    def String getDeploymentRef(FBasicTypeId _typeId, FInterface _interface, PropertyAccessor _accessor) {
        val String name = _typeId.getDeploymentName(_interface, _accessor)
        if (name != "")
            return "&" + name

        return "static_cast< " + _typeId.getDeploymentType(_interface, true) + "* >(nullptr)"
    }

    // Error deployment
    def String getErrorDeploymentType(FMethod _method, boolean _isArgument) {
        var String deploymentType = ""
        if (_method.hasError) {
            deploymentType = "CommonAPI::EmptyDeployment"
            if (_isArgument && !_method.outArgs.empty)
                deploymentType = deploymentType + ", "
        }
        return deploymentType
    }

    def Set<String> getDeploymentInputIncludes(FInterface _interface, PropertyAccessor _accessor) {
       var Set<String> ret = new HashSet<String>()
       for(x: _interface.attributes) {
          if(x.type.derived !== null) {
             ret.add(dbusDeploymentHeaderPath(x.type.derived.eContainer as FTypeCollection))
          }
            if(x.type.derived instanceof FTypeDef) {
                addDeploymentHeaderforTypeDef((x.type.derived as FTypeDef), ret)
            }
       }
       for(x: _interface.broadcasts) {
           for(y: x.outArgs) {
              if(y.type.derived !== null) {
                  ret.add(dbusDeploymentHeaderPath(y.type.derived.eContainer as FTypeCollection))
              }
            if(y.type.derived instanceof FTypeDef) {
                addDeploymentHeaderforTypeDef((y.type.derived as FTypeDef), ret)
            }
           }
           if(x.hasDeployedArgument(_accessor)) {
                ret.add(_interface.dbusDeploymentHeaderPath)
           }
       }
       for(x: _interface.methods) {
          for(y: x.outArgs) {
             if(y.type.derived !== null) {
               ret.add(dbusDeploymentHeaderPath(y.type.derived.eContainer as FTypeCollection))
             }
            if(y.type.derived instanceof FTypeDef) {
                addDeploymentHeaderforTypeDef((y.type.derived as FTypeDef), ret)
            }
          }
          for(y: x.inArgs) {
             if(y.type.derived !== null) {
               ret.add(dbusDeploymentHeaderPath(y.type.derived.eContainer as FTypeCollection))
             }
            if(y.type.derived instanceof FTypeDef) {
                addDeploymentHeaderforTypeDef((y.type.derived as FTypeDef), ret)
            }
          }
          if(x.hasDeployedArgument(_accessor, true, true)) {
                ret.add(_interface.dbusDeploymentHeaderPath)
           }
       }
       return ret
    }

    def addDeploymentHeaderforTypeDef(FTypeDef typedef, Set<String> headers) {

        var derived = typedef.actualType.derived
        if(derived !== null && (derived.eContainer as FTypeCollection) !== null) {
            headers.add(dbusDeploymentHeaderPath((typedef.actualType.derived.eContainer as FTypeCollection)))
        }
    }

}
